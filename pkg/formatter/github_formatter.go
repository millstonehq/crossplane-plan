package formatter

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/millstonehq/crossplane-plan/pkg/argocd"
	"github.com/millstonehq/crossplane-plan/pkg/differ"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"sigs.k8s.io/yaml"
)

// GitHubFormatter formats diffs for GitHub PR comments
type GitHubFormatter struct{}

// NewGitHubFormatter creates a new GitHubFormatter
func NewGitHubFormatter() *GitHubFormatter {
	return &GitHubFormatter{}
}

// FormatDiff formats a diff result as a GitHub-flavored markdown comment
func (f *GitHubFormatter) FormatDiff(xr *unstructured.Unstructured, result *differ.DiffResult) string {
	var b strings.Builder

	// Header
	b.WriteString("## üîÑ Crossplane Preview\n\n")
	
	// XR information
	b.WriteString(fmt.Sprintf("**Resource:** `%s/%s`\n", xr.GetKind(), xr.GetName()))
	if xr.GetNamespace() != "" {
		b.WriteString(fmt.Sprintf("**Namespace:** `%s`\n", xr.GetNamespace()))
	}
	b.WriteString("\n")

	// Summary
	if !result.HasChanges {
		b.WriteString("### ‚úÖ No Changes\n\n")
		b.WriteString("This PR will not modify any infrastructure resources.\n\n")
		// Footer
		b.WriteString("---\n")
		b.WriteString("_Generated by [crossplane-plan](https://github.com/millstonehq/crossplane-plan)_\n")
		return b.String()
	}

	// Changes detected
	b.WriteString("### üìã Changes Detected\n\n")
	b.WriteString(result.Summary)
	b.WriteString("\n\n")

	// Diff output
	b.WriteString("<details>\n")
	b.WriteString("<summary>üìù View Full Diff</summary>\n\n")
	b.WriteString("```diff\n")
	b.WriteString(result.RawDiff)
	b.WriteString("\n```\n")
	b.WriteString("</details>\n\n")

	// Infrastructure drift detection
	if len(result.ManagedResources) > 0 {
		f.formatInfrastructureDrift(&b, result.ManagedResources)
	}

	// Footer with transparency about stripped fields
	f.formatStrippedFieldsFooter(&b, result.StrippedFields)

	return b.String()
}

// formatInfrastructureDrift formats infrastructure drift detection results
func (f *GitHubFormatter) formatInfrastructureDrift(b *strings.Builder, managedResources []differ.ManagedResourceState) {
	// Check if any resources have drift
	hasDrift := false
	for _, mr := range managedResources {
		if len(mr.DeclaredVsActual) > 0 {
			hasDrift = true
			break
		}
	}

	if !hasDrift {
		return
	}

	b.WriteString("### ‚òÅÔ∏è Infrastructure State Analysis\n\n")
	b.WriteString("Comparing your declared configuration against actual infrastructure state:\n\n")

	for _, mr := range managedResources {
		if len(mr.DeclaredVsActual) == 0 {
			continue
		}

		resourceName := mr.Resource.GetKind() + "/" + mr.Resource.GetName()

		// Warning header based on management policy
		if mr.IsReadOnly {
			b.WriteString(fmt.Sprintf("#### ‚ö†Ô∏è `%s` (Read-Only Mode)\n\n", resourceName))
			b.WriteString("**Your declaration doesn't match actual infrastructure:**\n\n")
		} else {
			b.WriteString(fmt.Sprintf("#### ‚Üí `%s` (Will Modify Infrastructure)\n\n", resourceName))
			b.WriteString("**Infrastructure will be changed to match your declaration:**\n\n")
		}

		// Check if status.atProvider is available
		if !mr.HasAtProvider {
			b.WriteString("‚ö†Ô∏è **Warning:** Infrastructure state unavailable - resource not reconciled or error\n\n")
			if !mr.IsReady {
				b.WriteString("_Resource is not Ready. Check resource status for errors._\n\n")
			}
			continue
		}

		// Separate scalar and array/complex fields
		scalarFields := make(map[string]differ.FieldComparison)
		complexFields := make(map[string]differ.FieldComparison)

		for field, comparison := range mr.DeclaredVsActual {
			if isArrayOrSlice(comparison.Declared) || isArrayOrSlice(comparison.Actual) {
				complexFields[field] = comparison
			} else {
				scalarFields[field] = comparison
			}
		}

		// Show scalar fields in table
		if len(scalarFields) > 0 {
			b.WriteString("**Simple field differences:**\n\n")
			b.WriteString("| Field | Your Declaration | Actual Infrastructure |\n")
			b.WriteString("|-------|------------------|----------------------|\n")

			for field, comparison := range scalarFields {
				declaredStr := fmt.Sprintf("`%v`", comparison.Declared)
				actualStr := fmt.Sprintf("`%v`", comparison.Actual)
				b.WriteString(fmt.Sprintf("| `%s` | %s | %s |\n", field, declaredStr, actualStr))
			}
			b.WriteString("\n")
		}

		// Show array fields with set-based diff
		if len(complexFields) > 0 {
			b.WriteString("**Array/list field differences:**\n\n")
			for field, comparison := range complexFields {
				f.formatArrayDiff(b, field, comparison)
			}
		}

		// Show what will happen
		if mr.IsReadOnly {
			b.WriteString("```\n")
			b.WriteString("‚ÑπÔ∏è With managementPolicies: [Observe]:\n")
			b.WriteString("  ‚Ä¢ Infrastructure will NOT be modified\n")
			b.WriteString("  ‚Ä¢ This mismatch will persist after merge\n")
			b.WriteString("  \n")
			b.WriteString("  Options:\n")
			b.WriteString("  ‚Ä¢ Update your declaration to match infrastructure\n")
			b.WriteString("  ‚Ä¢ Remove Observe mode if you want to apply changes\n")
			b.WriteString("```\n\n")
		} else {
			b.WriteString("```\n")
			b.WriteString("‚Üí Infrastructure WILL be modified to match your spec\n")
			b.WriteString("```\n\n")
		}
	}
}

// FormatMultipleDiffs formats multiple XR diffs into a single comment
// argocdDiff is optional - pass nil if ArgoCD integration is not available
func (f *GitHubFormatter) FormatMultipleDiffs(results map[string]*differ.DiffResult, argocdDiff *argocd.AppDiff) string {
	var b strings.Builder

	// Header
	b.WriteString("## üîÑ Crossplane Preview\n\n")

	// ArgoCD Sync Preview Section (if available)
	if argocdDiff != nil {
		f.formatArgoCDDiff(&b, argocdDiff)
		b.WriteString("---\n\n")
	}

	// Count total changes
	totalChanges := 0
	totalResources := len(results)
	for _, result := range results {
		if result.HasChanges {
			totalChanges++
		}
	}

	// Summary
	b.WriteString(fmt.Sprintf("**Resources:** %d total, %d with changes\n\n", totalResources, totalChanges))

	if totalChanges == 0 && argocdDiff == nil {
		b.WriteString("### ‚úÖ No Changes\n\n")
		b.WriteString("This PR will not modify any infrastructure resources.\n")
		return b.String()
	}

	if totalChanges == 0 {
		// We have ArgoCD diff but no crossplane-diff changes
		b.WriteString("### ‚úÖ No Composition Changes\n\n")
		b.WriteString("Crossplane compositions will not create additional resources.\n\n")
		f.formatStrippedFieldsFooter(&b, []differ.StrippedField{})
		return b.String()
	}

	// Add header for composition preview section
	b.WriteString("### üîß Crossplane Composition Preview\n\n")

	// Separate modifications and deletions for better presentation
	modifications := make(map[string]*differ.DiffResult)
	deletions := make(map[string]*differ.DiffResult)

	for name, result := range results {
		if result.HasChanges {
			if strings.HasPrefix(name, "DELETED-") {
				// Strip the prefix for display
				actualName := strings.TrimPrefix(name, "DELETED-")
				deletions[actualName] = result
			} else {
				modifications[name] = result
			}
		}
	}

	// List modified resources
	if len(modifications) > 0 {
		b.WriteString("### üìã Modified Resources\n\n")
		for name, result := range modifications {
			b.WriteString(fmt.Sprintf("- **%s**: %s\n", name, result.Summary))
		}
		b.WriteString("\n")
	}

	// List deleted resources (with warning)
	if len(deletions) > 0 {
		b.WriteString("### üóëÔ∏è Deleted Resources\n\n")
		for name, result := range deletions {
			b.WriteString(fmt.Sprintf("- **%s**: %s\n", name, result.Summary))
		}
		b.WriteString("\n")
	}

	// Individual diffs for modifications
	for name, result := range modifications {
		b.WriteString(fmt.Sprintf("### `%s`\n\n", name))
		b.WriteString("<details>\n")
		b.WriteString("<summary>üìù View Diff</summary>\n\n")
		b.WriteString("```diff\n")
		b.WriteString(result.RawDiff)
		b.WriteString("\n```\n")
		b.WriteString("</details>\n\n")
	}

	// Individual diffs for deletions
	for name, result := range deletions {
		b.WriteString(fmt.Sprintf("### `%s` (DELETION)\n\n", name))
		b.WriteString("> **‚ö†Ô∏è WARNING:** This resource will be **DELETED** when the PR is merged.\n\n")
		b.WriteString("<details>\n")
		b.WriteString("<summary>üìÑ View Resource Details</summary>\n\n")
		b.WriteString("```yaml\n")
		// Format the XR as YAML for display
		if result.XR != nil {
			yamlBytes, err := yaml.Marshal(result.XR.Object)
			if err == nil {
				b.WriteString(string(yamlBytes))
			} else {
				b.WriteString(result.RawDiff)
			}
		} else {
			b.WriteString(result.RawDiff)
		}
		b.WriteString("\n```\n")
		b.WriteString("</details>\n\n")
	}

	// Collect all stripped fields from all results
	var allStrippedFields []differ.StrippedField
	seenFields := make(map[string]bool)
	for _, result := range results {
		for _, field := range result.StrippedFields {
			// Deduplicate by path (same fields stripped across multiple XRs)
			if !seenFields[field.Path] {
				allStrippedFields = append(allStrippedFields, field)
				seenFields[field.Path] = true
			}
		}
	}

	// Footer with transparency about stripped fields
	f.formatStrippedFieldsFooter(&b, allStrippedFields)

	return b.String()
}

// formatArgoCDDiff formats the ArgoCD Application diff section
func (f *GitHubFormatter) formatArgoCDDiff(b *strings.Builder, diff *argocd.AppDiff) {
	b.WriteString("### üì¶ ArgoCD Sync Preview\n\n")
	b.WriteString("The following changes will be applied when this PR merges:\n\n")

	totalChanges := len(diff.Additions) + len(diff.Modifications) + len(diff.Deletions)
	if totalChanges == 0 {
		b.WriteString("**No ArgoCD-managed resource changes detected.**\n\n")
		return
	}

	// Summary counts
	summary := []string{}
	if len(diff.Additions) > 0 {
		summary = append(summary, fmt.Sprintf("**%d** new", len(diff.Additions)))
	}
	if len(diff.Modifications) > 0 {
		summary = append(summary, fmt.Sprintf("**%d** modified", len(diff.Modifications)))
	}
	if len(diff.Deletions) > 0 {
		summary = append(summary, fmt.Sprintf("**%d** deleted", len(diff.Deletions)))
	}
	b.WriteString(strings.Join(summary, ", "))
	b.WriteString("\n\n")

	// Show additions
	if len(diff.Additions) > 0 {
		b.WriteString("**‚ú® New Resources:**\n\n")
		for _, add := range diff.Additions {
			resourceID := fmt.Sprintf("%s/%s", add.GVK.Kind, add.Name)
			if add.Namespace != "" {
				resourceID = fmt.Sprintf("%s/%s (%s)", add.GVK.Kind, add.Name, add.Namespace)
			}
			b.WriteString(fmt.Sprintf("- `%s`\n", resourceID))
		}
		b.WriteString("\n")
	}

	// Show modifications
	if len(diff.Modifications) > 0 {
		b.WriteString("**‚úèÔ∏è Modified Resources:**\n\n")
		for _, mod := range diff.Modifications {
			resourceID := fmt.Sprintf("%s/%s", mod.GVK.Kind, mod.Name)
			if mod.Namespace != "" {
				resourceID = fmt.Sprintf("%s/%s (%s)", mod.GVK.Kind, mod.Name, mod.Namespace)
			}
			b.WriteString(fmt.Sprintf("- `%s`\n", resourceID))
		}
		b.WriteString("\n")
	}

	// Show deletions with warning
	if len(diff.Deletions) > 0 {
		b.WriteString("**‚ö†Ô∏è Resources to be Deleted:**\n\n")
		for _, del := range diff.Deletions {
			resourceID := fmt.Sprintf("%s/%s", del.GVK.Kind, del.Name)
			if del.Namespace != "" {
				resourceID = fmt.Sprintf("%s/%s (%s)", del.GVK.Kind, del.Name, del.Namespace)
			}
			b.WriteString(fmt.Sprintf("- üóëÔ∏è `%s` will be **pruned** by ArgoCD\n", resourceID))
		}
		b.WriteString("\n")
	}

	// Optional: Full diff details
	if diff.RawDiff != "" {
		b.WriteString("<details>\n")
		b.WriteString("<summary>üìÑ View Full ArgoCD Diff</summary>\n\n")
		b.WriteString("```diff\n")
		b.WriteString(diff.RawDiff)
		b.WriteString("\n```\n")
		b.WriteString("</details>\n\n")
	}
}

// formatStrippedFieldsFooter adds a transparency footer showing stripped fields
func (f *GitHubFormatter) formatStrippedFieldsFooter(b *strings.Builder, strippedFields []differ.StrippedField) {
	b.WriteString("---\n")
	b.WriteString("_Generated by [crossplane-plan](https://github.com/millstonehq/crossplane-plan)_\n")

	// Only show stripped fields section if fields were actually stripped
	if len(strippedFields) == 0 {
		return
	}

	b.WriteString("\n")
	b.WriteString("<details>\n")
	b.WriteString("<summary>‚ÑπÔ∏è Diff excludes deployment-specific overrides</summary>\n\n")
	b.WriteString("The following fields are hidden as they represent temporary PR environment configuration:\n\n")
	b.WriteString("| Field | Reason |\n")
	b.WriteString("|-------|--------|\n")

	for _, field := range strippedFields {
		b.WriteString(fmt.Sprintf("| `%s` | %s |\n", field.Path, field.Reason))
	}

	b.WriteString("\n")
	b.WriteString("These overrides won't persist when merged to main.\n\n")
	b.WriteString("_To disable field stripping, set `--no-strip-defaults` flag_\n")
	b.WriteString("</details>\n")
}

// isArrayOrSlice checks if a value is an array or slice
func isArrayOrSlice(v interface{}) bool {
	if v == nil {
		return false
	}
	rv := reflect.ValueOf(v)
	k := rv.Kind()
	return k == reflect.Array || k == reflect.Slice
}

// formatArrayDiff formats array differences using set-based comparison
func (f *GitHubFormatter) formatArrayDiff(b *strings.Builder, field string, comparison differ.FieldComparison) {
	declaredItems := toStringSlice(comparison.Declared)
	actualItems := toStringSlice(comparison.Actual)

	additions := setDiff(declaredItems, actualItems)
	removals := setDiff(actualItems, declaredItems)
	orderDiffers := !slicesEqual(declaredItems, actualItems)

	b.WriteString(fmt.Sprintf("- **`%s`**: ", field))

	if len(additions) == 0 && len(removals) == 0 {
		if orderDiffers {
			b.WriteString("Order differs\n")
		} else {
			b.WriteString("No changes (should not appear)\n")
		}
	} else {
		parts := []string{}
		if len(additions) > 0 {
			parts = append(parts, fmt.Sprintf("%d addition(s)", len(additions)))
		}
		if len(removals) > 0 {
			parts = append(parts, fmt.Sprintf("%d removal(s)", len(removals)))
		}
		if orderDiffers && len(additions) == 0 && len(removals) == 0 {
			parts = append(parts, "order differs")
		}
		b.WriteString(strings.Join(parts, ", "))
		b.WriteString("\n")

		if len(additions) > 0 {
			b.WriteString(fmt.Sprintf("  - Additions: `%s`\n", formatStringSlice(additions)))
		}
		if len(removals) > 0 {
			b.WriteString(fmt.Sprintf("  - Removals: `%s`\n", formatStringSlice(removals)))
		}
		if orderDiffers && len(additions) == 0 && len(removals) == 0 {
			b.WriteString("  - Note: Items are the same but order differs\n")
		}
	}
	b.WriteString("\n")
}

// toStringSlice converts an interface{} to a string slice for comparison
func toStringSlice(v interface{}) []string {
	if v == nil {
		return []string{}
	}

	rv := reflect.ValueOf(v)
	if rv.Kind() != reflect.Array && rv.Kind() != reflect.Slice {
		// Not an array/slice, return string representation
		return []string{fmt.Sprintf("%v", v)}
	}

	result := make([]string, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		result[i] = fmt.Sprintf("%v", rv.Index(i).Interface())
	}
	return result
}

// setDiff returns elements in a that are not in b
func setDiff(a, b []string) []string {
	bSet := make(map[string]bool)
	for _, item := range b {
		bSet[item] = true
	}

	var diff []string
	for _, item := range a {
		if !bSet[item] {
			diff = append(diff, item)
		}
	}
	return diff
}

// slicesEqual checks if two string slices are equal (order matters)
func slicesEqual(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// formatStringSlice formats a string slice for display
func formatStringSlice(items []string) string {
	if len(items) == 0 {
		return "(none)"
	}
	return strings.Join(items, ", ")
}
